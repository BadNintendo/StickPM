/*  ██╗██╗                                                                                           ██╗██╗
 *  ██║╚═╝  ███████╗████████╗██╗ ██████╗██╗  ██╗██████╗ ███╗   ███╗     ██████╗ ██████╗ ███╗   ███╗  ╚═╝██║
 *  ██║     ██╔════╝╚══██╔══╝██║██╔════╝██║ ██╔╝██╔══██╗████╗ ████║    ██╔════╝██╔═══██╗████╗ ████║     ██║
 *  ██║     ███████╗   ██║   ██║██║     █████╔╝ ██████╔╝██╔████╔██║    ██║     ██║   ██║██╔████╔██║     ██║
 *  ██║     ╚════██║   ██║   ██║██║     ██╔═██╗ ██╔═══╝ ██║╚██╔╝██║    ██║     ██║   ██║██║╚██╔╝██║     ██║
 *  ██║     ███████║   ██║   ██║╚██████╗██║  ██╗██║     ██║ ╚═╝ ██║ ██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║     ██║
 *  ██║██╗  ╚══════╝   ╚═╝   ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝     ╚═╝     ╚═╝ ╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝  ██╗██║
 *  ╚═╝╚═╝                                                                                           ╚═╝╚═╝
 * StickPM Project
 * © 2024 BadNintendo - JSON Database Module
 * All rights reserved.
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * 
 * USAGE:
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * 
 * You are permitted to use this software for personal and commercial
 * applications, provided the following conditions are met:
 * 1. The origin of this software must not be misrepresented; you must
 *	not claim that you wrote the original software.
 * 2. Altered source versions must be plainly marked as such, and must
 *	not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source
 *	distribution.
 * 
 * CONTEXT:
 * This module handles data storage, user management, room management, 
 * message handling, stream management, and various utility functions. 
 * It loads the database from a JSON file and provides methods for CRUD operations 
 * on users, rooms, messages, and streams, and includes functions for account 
 * verification and password reset processes.
 * 
 * Need To-Do:
 * 1. Look into room database roles array storing object data if needs to change over to object without array
 * 
 * Ideas To-Think On:
 * 1. custom room themes to further changing default colors of page
 * 2. custom room sound notifications for vip rooms that add a custom sounds to room theme
 * 3. text based games with extra assigned roles like changing profiles pretending to be someone who opted into the role
 * 4. clean activities and stream storage data unless flagged [add flagged by recent kick, ban, susp]
 */

const QPRx2025 = require('./QPRx2025');
const path = require('path');
const fs = require('fs');

/** Path to the database file */
const dbFilePath = path.join(__dirname, 'database.json');

/**  Directory and filename management */
const logsDirectory = path.join(__dirname, 'logs');
if (!fs.existsSync(logsDirectory)) fs.mkdirSync(logsDirectory);

/** Function to get the path of the current log file 
 * @returns {string} Path of the current or a new log file
 */
const getLogFilePath = () => {
	const files = fs.readdirSync(logsDirectory).filter(f => f.endsWith('.json'));
	if (files.length === 0) return path.join(logsDirectory, `activity-${new Date().toISOString().split('T')[0]}.json`);
	files.sort((a, b) => fs.statSync(path.join(logsDirectory, b)).mtime.getTime() - fs.statSync(path.join(logsDirectory, a)).mtime.getTime());
	return path.join(logsDirectory, files[0]);
  };

/** Read and parse the database JSON file.
 * @returns {Object} - Parsed JSON object from the database file.
 */
const readDatabase = () => {
	if (fs.existsSync(dbFilePath)) {
		const data = fs.readFileSync(dbFilePath, 'utf-8');
		return JSON.parse(data);
	}
	return initializeDefaultDatabase();
};

/** Write data to the database JSON file.
 * @param {Object} data - Data to be written to the database file.
 */
const writeDatabase = (data) => fs.writeFileSync(dbFilePath, JSON.stringify(data, null, 2));

/** Utility function to handle errors.
 * @param {Error} error - The error object.
 */
const handleError = (error) => {
	console.error(error.message);
	throw new Error(error.message);
};

/** Ensure the lobby room exists on load.
 * @param {Object} data - The database object.
 */
const ensureLobbyRoomExists = (data) => {
	if (!data.rooms.lobby) {
		data.rooms.lobby = createLobbyRoom();
		writeDatabase(data);
	}
};

/** Add a test user to the database if not already present.
 * @param {Object} data - The database object.
 */
const addUserToDatabase = (data) => {
	if (Array.isArray(data.users)) {
		const userExists = data.users.find(user => user.id === 'testuser');
		if (!userExists) {
			data.users.push(createTestUser());
			writeDatabase(data);
		}
	}
};

/** Utility function to rotate the log file 
 * @returns {string} Path of the new log file
 */
const rotateLogFile = () => {
  const oldLogFilePath = getLogFilePath();
  const newLogFilePath = path.join(logsDirectory, `activity-${new Date().toISOString().replace(/:/g, '-')}.json`);
  fs.renameSync(oldLogFilePath, newLogFilePath);
  return newLogFilePath;
};

/** Writes logs to the file with a check for rotation 
 * @param {Object} data Log data to be written to the file
 */
const writeLog = (data) => {
  let logFilePath = getLogFilePath();
  if (needsRotation(logFilePath, 25)) {
    logFilePath = rotateLogFile();
  }
  fs.appendFileSync(logFilePath, JSON.stringify(data, null, 2) + '\n');
};

/** Checks if a file needs rotation based on file size 
 * @param {string} filePath Path of the log file
 * @param {number} maxSizeMB Maximum size of the file in MB before rotation
 * @returns {boolean} True if the file needs rotation; otherwise, false
 */
const needsRotation = (filePath, maxSizeMB) => {
  if (!fs.existsSync(filePath)) return false;
  const stats = fs.statSync(filePath);
  return stats.size >= maxSizeMB * 1024 * 1024;
};

/** Initialization of logs and database on startup */
const initializeLogsAndDatabase = () => {
  const currentLogFilePath = getLogFilePath();
  if (!fs.existsSync(currentLogFilePath)) {
    fs.writeFileSync(currentLogFilePath, '');
  }
};
initializeLogsAndDatabase();

/** Utility function to log user activity.
 * @param {string} userId - ID of the user.
 * @param {string} activity - Activity description.
 * @param {string} [roomId=null] - ID of the room where the activity occurred (optional).
 */
const logActivity = (userId, activity, roomId = null) => {
	//database.activities.push({ userId, activity, roomId, timestamp: new Date() });
	//writeDatabase(database);
	const logEntry = { userId, activity, roomId, timestamp: new Date() };
	let logs = [];
	const logFilePath = getLogFilePath();
	if (fs.existsSync(logFilePath)) {
		const logData = fs.readFileSync(logFilePath, 'utf-8');
		logs = logData.trim() ? logData.split('\n').map(line => JSON.parse(line)) : [];
	}
	logs.push(logEntry);
	writeLog(logEntry);
};

/** Create a default admin user.
 * @returns {Object} - Default admin user object.
 */
const createAdminUser = () => ({
	id: QPRx2025.generateUUID(),
	username: 'Admin',
	password: QPRx2025.customHash(process.env.DEVPASS, process.env.HASHUSERSALT || 10),
	email: `admin@${process.env.DOMAIN}`,
	profilePhoto: 'data:image/jpeg;base64,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' || '/images/user-avatar.png',
	approveAvatar: true,
	firstName: '',
	lastName: '',
	phone: '',
	code: '',
	twoFactorEnabled: false,
	verified: true,
	privacy: false,
	games: true,
	isVip: true,
	name: 'Admin User',
	role: 'developer',
	bio: 'Creator of StickPM',
	joinDate: new Date(),
	following: [],
	blocked: [],
	credits: {
		amount: 999,
		lastTransactionDate: null,
		paymentDetails: {}
	}
});

/** Create a lobby room.
 * @returns {Object} - Default lobby room object.
 */
const createLobbyRoom = () => ({
	id: 'lobby',
	name: 'Lobby',
	owner: 'admin',
	topic: '',
	settings: {},
	suspendedUsers: [],
	mutedUsers: [],
	messages: [],
	admins: [],
	roles: [],
	users: [],
	vip: true,
	locked: false,
	slowMode: false,
	allowGuests: true,
	contentProtection: false,
	createdOn: new Date(),
	donation: 100,
	lastDonationDate: 'expired',
	allowedRoles: ['moderator', 'super', 'admin', 'owner', 'developer'],
	memberAllowedRoles: ['member', 'moderator', 'super', 'admin', 'owner', 'developer']
});

/** Initialize a default database with an admin user and a lobby room.
 * @returns {Object} - Initial database object.
 */
const initializeDefaultDatabase = () => {
	const defaultAdmin = createAdminUser();
	const lobbyRoom = createLobbyRoom();
	const initialData = {
		rooms: { 'lobby': lobbyRoom },
		users: [defaultAdmin],
		clips: [],
		roles: [],
		polls: [],
		badges: [],
		streams: [],
		analytics: [],
		activities: [],
		recordings: [],
		socialShares: [],
		loyaltyPoints: [],
		recommendations: [],
		files: {},
		follows: {},
		messages: {},
		rateLimits: {},
		leaderboards: {}
	};
	writeDatabase(initialData);
	return initialData;
};

/** Create a test user.
 * @returns {Object} - Test user object.
 */
const createTestUser = () => ({
	id: 'testuser',
	role: 'tester',
	username: 'Test User',
	roomsAccess: ['lobby'],
	isGuest: false
});

/** Loads database */
const database = readDatabase();
ensureLobbyRoomExists(database);
addUserToDatabase(database);

const restrictedNames = [
	'moderator', 'super', 'admin', 'owner', 'developer', 'member', 'guest', 'subscriber', 'contributor', 
	'volunteer', 'support', 'manager', 'lead', 'coordinator', 'executive', 'director', 'chief', 
	'assistant', 'agent', 'specialist', 'consultant', 'analyst', 'strategist', 'designer', 'editor', 
	'reviewer', 'author', 'creator', 'curator', 'producer', 'projectmanager', 'teamleader', 
	'supervisor', 'technician', 'engineer', 'architect', 'developeradvocate', 'evangelist', 'administrator', 
	'moderatorinchief', 'communitymanager', 'ambassador', 'champion', 'mentor', 'coach', 'trainer', 
	'facilitator', 'organizer', 'planner', 'scheduler', 'researcher', 'datascientist', 'developermanager', 
	'qualityassurance', 'supportspecialist', 'helpdesk', 'itsupport', 'webmaster', 'sysadmin', 'databaseadmin', 
	'networkengineer', 'systemsanalyst', 'businessanalyst', 'operationsmanager', 'broadcaster', 'streamer', 
	'viewer', 'chatter', 'camhost', 'camguest', 'roomowner', 'roomadmin', 'roommod', 'kick', 'ban', 'mute', 
	'unmute', 'block', 'unblock', 'highlight', 'modview', 'vip', 'premium', 'regular', 'participant', 'host', 
	'cohost', 'dj', 'operator', 'sysop', 'ircop', 'webcam', 'livestream', 'broadcast', 'caster', 'vidcaster', 
	'audiocaster', 'livemod', 'chatmod', 'vidmod', 'textmod', 'audiohost', 'videohost', 'contentcreator', 
	'socialstreamer', 'eventhost', 'roommanager', 'broadcastmanager', 'livemanager', 'chatmanager', 
	'eventmanager', 'showhost', 'liveproducer', 'audience', 'listener', 'attendee', 'participant',
	'liveadmin', 'streammanager', 'mediahost', 'mediamod', 'communitymod', 'forumadmin', 'forumsupport', 
	'webadmin', 'websupport', 'channelowner', 'channelmod', 'channeladmin', 'videoeditor', 'videoanalyst', 
	'musicdj', 'techsupport', 'techlead', 'productowner', 'productmanager', 'eventplanner', 'communitylead', 
	'socialmedia', 'socialmod', 'contentmod', 'discussionsadmin', 'discussionsmod', 'discordadmin', 'discordmod', 
	'gameadmin', 'gamemod', 'gamer', 'gamingadmin', 'gamingmod', 'gamesupport', 'techspecialist', 'securityadmin', 
	'securitymod', 'chatroomadmin', 'chatroommod', 'chatroomowner', 'channellead', 'communitysupport', 'eventsupport',
	'audiencelead', 'hostmanager', 'streammod', 'livestreamadmin', 'livestreammod', 'forumlead', 'gaminglead', 
	'videomanager', 'videoexpert', 'supportlead', 'webmoderator', 'webtechnician', 'webmanager', 'webanalyst',
	'mod', 'sys', 'sysadmin', 'root', 'master', 'adminuser', 'moduser', 'superuser', 'chiefmod', 'vipmod', 
	'gamehost', 'quizmaster', 'buzz', 'serveradmin', 'operator', 'trust', 'advisor', 'security', 'gatekeeper', 
	'portaladmin', 'keeper', 'gate', 'controller', 'taskmaster', 'gatekeeper', 'controller', 'agentadmin',
	'channelhost', 'linelead', 'mastermod', 'trustee', 'warden', 'defender', 'custodian', 'gatewatch', 'sentinel', 
	'enforcer', 'usher', 'moderate', 'chatlead', 'convener', 'referee', 'marshaler', 'guardian', 'proxy', 
	'proctor', 'invigilator', 'arbiter', 'judge', 'monarch', 'patron', 'protector', 'overseer', 'surveyor', 
	'conservator', 'janitor', 'curate', 'caretaker', 'watcher', 'watchguard', 'beadle', 'gatemod', 'guidemod',
	'wardenmod', 'gamesmod', 'netmod', 'chatchief', 'chatmodchief', 'roomchief', 'netadmin', 'guard', 'mediamod', 
	'netmoderator', 'netmanager', 'networkadmin', 'netchief', 'nodeadmin', 'nodeguard', 'netguard', 'modboss', 
	'leadadmin', 'primeadmin', 'trustmod', 'forumhost', 'forumchief', 'forumlead', 'boardadmin', 'boardmod', 
	'boardleader', 'forumcoordinator', 'channelmaster', 'paneladmin', 'panelmod', 'channelmaster', 'chatmaster',
	'modlead', 'leadmod', 'chiefadmin', 'chiefop', 'chiefuser', 'forumlead', 'channelleader', 'channelguard',
	'netlead', 'roomlead', 'leadroom', 'livemanager', 'livemoderator', 'livetask', 'taskmod', 'roommodchief',
	'streammodchief', 'chiefop', 'chatroomchief', 'boardlead', 'chiefstreamer', 'contentlead', 'contenthead',
	'tasklead', 'taskchief', 'streamchief', 'chiefstream', 'streamhead', 'chiefhost', 'chiefmoderator', 
	'webadminchief', 'chiefmonitor', 'teamchief', 'forumadminchief', 'boardchief', 'masteradmin', 'mastermod', 
	'masterleader', 'headmod', 'leadhead', 'teamlead', 'teamchief', 'sectionlead', 'sectionchief', 'sectionadmin', 
	'sectionmod', 'taskadmin', 'taskchief', 'taskmanager', 'streamleader', 'leadstreamer', 'chiefstreammod', 'profile',
	'users', 'room', 'rooms', 'lobby', 'stickpm', 'ceo', 'domain', 'credits', 'donation', 'donations'
];

const badWords = ['69', '0rgasms', '3jakulating', '4r5e', '4r5ed', '4r5es', '4skin', '5h17', '5h1t', '5kank', 'abbie', 
	'abeed', 'aboe', 'anal', 'analingus', 'analplug', 'analplugs', 'anilingus', 'anus', 'apeshit', 'apeshite', 'ar5e', 'ar5ehole', 'arse', 'arsefuck', 'arsefucker', 
	'arsehole', 'arseshit', 'arsewipe', 'ashole', 'ass', 'asses', 'assface', 'assfck', 'assfcker', 'assfk', 'assfkcer', 'assfker', 'assfkr', 'assfook', 'assfuccer', 
	'assfuck', 'assfuck3r', 'assfucker', 'assfuckers', 'assfuckerz', 'assfukah', 'assfukka', 'assfukker', 'assfukkerz', 'assfvck3r', 'assfvcker', 'asshat', 'asshol3', 
	'asshole', 'assholes', 'assmunch', 'assmuncher', 'asswhole', 'asswipe', 'azz', 'azzhole', 'b00bz', 'b0llock', 'b0llocks', 'b17ch', 'b1otch', 'b1otchs', 'b1tch', 
	'b1tch1ng', 'b1tch35', 'b1tch3s', 'b1tchees', 'b1tches', 'b1tchez', 'b1tchin', 'b1tching', 'b1tchs', 'b1tchy', 'ballbag', 'bangbros', 'bassturd', 'bastard', 
	'bastardish', 'bastards', 'basterd', 'bastid', 'bastinado', 'basturd', 'bater', 'bates', 'batshit', 'batshite', 'bbc', 'beaner', 'beaners', 'beeotch', 'bellend', 
	'bender', 'bewbs', 'beyoch', 'beyotch', 'biatch', 'biches', 'biotch', 'biotches', 'biotchez', 'bishes', 'bitch', 'bitch3s', 'bitchass', 'bitchasses', 'bitched', 
	'bitcher', 'bitchers', 'bitches', 'bitchez', 'bitchfuck', 'bitchhole', 'bitchin', 'bitching', 'bitchlike', 'bitchness', 'bitchs', 'bitchslap', 'bitchtits', 
	'bitchy', 'bizzach', 'BJ', 'blacky', 'blowjob', 'boll0ck', 'bollock', 'bollockchops', 'bollocks', 'bollocktician', 'bollox', 'bondage', 'boner', 'boobs', 'booty', 
	'breasticles', 'breasts', 'bugger', 'bullshi', 'bullshit', 'bullshite', 'bumhole', 'buttermilk', 'buttfuck', 'buttfucker', 'buttfuckers', 'butthole', 'bwc', 
	'c00n', 'c00nies', 'c0ck', 'c0ckhead', 'c0cks', 'c0cksuccer', 'c0cksucked', 'c0cksucker', 'c0cksuckers', 'c0x', 'c0xux0r', 'caaak', 'caca', 'cack', 'cagone', 
	'cajones', 'cameltoe', 'carpetmuncher', 'carpetmunchers', 'carpetmunching', 'cawk', 'cawkmuncher', 'cawks', 'cawksucker', 'ch1nk', 'chesticles', 'chinavirus', 
	'chingchong', 'chink', 'chinky', 'chocha', 'cholo', 'clitlickers', 'clusterfuck', 'clusterfucked', 'clusterfucker', 'clusterfucking', 'clusterfucks', 'cock', 
	'cockboy', 'cockeater', 'cockface', 'cockgobbler', 'cockh3ad', 'cockhead', 'cockheads', 'cockhed', 'cockless', 'cocklicker', 'cockmonger', 'cockmunch', 
	'cockmuncher', 'cocks', 'cockshit', 'cockskin', 'cocksmoker', 'cocksucc', 'cocksuccas', 'cocksuccer', 'cocksuccers', 'cocksuck', 'cocksuckas', 'cocksucked', 
	'cocksucker', 'cocksuckers', 'cocksucking', 'cocksucks', 'cocksuk', 'cocksuka', 'cocksukka', 'cocsuck', 'cokmuncher', 'coksucka', 'coolie', 'coon', 'coon1es', 
	'cooni3s', 'coonie', 'coonies', 'coons', 'coot', 'cooter', 'cooterpuffing', 'cooties', 'creampie', 'crotch', 'crotchy', 'crow', 'crows', 'cuksuker', 'cuksukka', 
	'cumball', 'cumdumpster', 'cumming', 'cums', 'cumslut', 'cumz', 'cunnilingus', 'cunt', 'cuntbag', 'cuntbollock', 'cuntelope', 'cuntits', 'cuntless', 'cuntlick', 
	'cuntlicker', 'cuntlickers', 'cuntness', 'cunts', 'cunty', 'cuntz', 'cuunt', 'cyberfck', 'cyberfcks', 'cyberfuccs', 'cyberfucks', 'cyberfucs', 'cyberfukk', 
	'cyberfukks', 'cyberfvcks', 'd1ck', 'd1ckhead', 'd1ckheads', 'd1cks', 'd1cksucker', 'd1cksukka', 'd1ckz', 'd1ldo', 'dafuq', 'dago', 'darkass', 'darkfuck', 
	'darkie', 'darkshit', 'darktard', 'darky', 'dickface', 'dickfucker', 'dickhead', 'dickheads', 'dickjockies', 'dickless', 'dicklicker', 'dickmuncher', 'dicks', 
	'dickskin', 'dickslapper', 'dicksmoker', 'dicksucker', 'dickvag', 'dickz', 'diddle', 'dikhead', 'diks', 'dild0', 'dipsh1t', 'dipsh1tty', 'dipshat', 'dipshidiot', 
	'dipshit', 'dipshite', 'dipshits', 'dipshitter', 'dipshitty', 'dipstick', 'dix', 'dlck', 'dlcks', 'dogsh1t', 'dogsh1ts', 'dogshit', 'dogshits', 'dogstyle', 
	'dolt', 'dong', 'doosh', 'dothead', 'douche', 'douchebag', 'dumasses', 'dumbarrassed', 'dumbass', 'dumbasses', 'dumbfucks', 'dumbshit', 'dyke', 'erectoplasm', 
	'f0ck', 'f0cked', 'f0cker', 'f0ckers', 'fack', 'fackuhs', 'fag', 'fag0t', 'faget', 'fagg0t', 'fagging', 'faggo', 'faggot', 'faggoting', 'faggots', 'faggs', 
	'faggy', 'fagot', 'fags', 'fagshit', 'fatass', 'fatasses', 'fccuker', 'fck', 'fcka', 'fckahz', 'fcked', 'fckedup', 'fcker', 'fckin', 'fcking', 'Fckk', 'fckked', 
	'fckking', 'fcks', 'fcktard', 'fckyeah', 'fcuk', 'fcuked', 'fcuker', 'fcukers', 'fcuking', 'fcukker', 'fcuks', 'fcvking', 'feck', 'fecker', 'feg', 'fellator', 
	'fick', 'finger', 'fingerbanged', 'fingerpop', 'fkbny', 'fked', 'fker', 'fking', 'fkings', 'fkker', 'flamer', 'flamers', 'focker', 'fook', 'fooker', 'fookuh', 
	'forked', 'fothermuckers', 'fuc', 'fucc', 'fucca', 'fuccers', 'fuccing', 'fuccs', 'Fuck', 'fucka', 'fuckahs', 'fuckass', 'fuckasses', 'fuckaz', 'fuckbag', 
	'fuckboy', 'fucked', 'fuckem', 'fucker', 'fuckers', 'fuckface', 'fuckfaces', 'fuckhead', 'fuckheaded', 'fuckheads', 'fuckin', 'fucking', 'fuckk', 'fuckless', 
	'fuckmachine', 'fucknuckle', 'fucks', 'fuckshit', 'fuckshitface', 'fuckshithead', 'fuckstar', 'fuckster', 'fuckstick', 'fucktard', 'fucktards', 'fuckup', 
	'fuckwad', 'fuckwhore', 'fucs', 'fucx', 'fudgefucker', 'fudgepacker', 'fudgepackers', 'fudgepackershitter', 'fugged', 'fugger', 'fuggerz', 'fuggings', 'fugly', 
	'fuk', 'fuk1n', 'fuk1ng', 'fukcs', 'fuker', 'fukheads', 'fukin', 'fuking', 'fukk', 'fukka', 'fukked', 'fukker', 'fukkers', 'fukking', 'fukkings', 'fukkuh', 
	'fuks', 'fuku', 'fukwhore', 'fukwit', 'funbags', 'fuq', 'futhamucka', 'fux', 'fux0r', 'fvck', 'fvcka', 'fvckbunny', 'fvcker', 'fvckers', 'fvckin', 'fvcking', 
	'fvckwhi', 'fxck', 'fxcked', 'fxcker', 'fxcking', 'g0ddamn', 'g0ddamned', 'g0ddamnit', 'gayest', 'gaylord', 'gaylords', 'gayness', 'gaysian', 'gaytard', 'geebag', 
	'girlieboy', 'girlyboy', 'gobshite', 'godamnit', 'goddammit', 'goddamn', 'goddamned', 'goddamnit', 'gook', 'gowl', 'greaser', 'groid', 'groper', 'gyp', 'heeb', 
	'higg3r', 'higga', 'higger', 'higgers', 'hoar', 'hoe', 'hoebag', 'hoes', 'homo', 'homos', 'hooters', 'horseshit', 'hustler', 'injun', 'j3rk', 'ja1lbait', 
	'jackarse', 'jackass', 'jackasses', 'jackasss', 'jackoff', 'jackoffs', 'jackoffz', 'jagoff', 'jailbait', 'jap', 'jerkoff', 'jerkoffs', 'jewboy', 'jigaboo', 
	'jigaboos', 'jigga', 'jiggaboo', 'jiggabooboo', 'jiggaboos', 'jiggabu', 'jiggas', 'jigger', 'jiggerboo', 'jiggerboos', 'jiggs', 'jiggyboo', 'jigro', 'jizz', 
	'jizzbags', 'jizzed', 'jizzes', 'jizzfucker', 'jizzing', 'jizzsacks', 'jizzstain', 'jizzy', 'k1k3', 'k1ke', 'kike', 'kikes', 'kkk', 'klan', 'klitoris', 
	'kneegrows', 'knickers', 'knob', 'knob3d', 'knob3nd', 'knobd', 'knobe', 'knobead', 'knobeads', 'knobed', 'knobeds', 'knobend', 'knobender', 'knobends', 
	'knobendy', 'knobendz', 'knober', 'knobes', 'knobgobbler', 'knobhead', 'knobheads', 'knobjockies', 'knobjocky', 'knobjokey', 'knobjokeys', 'kyke', 'l3itch', 
	'l3itches', 'ladboys', 'ladboyz', 'ladiboy', 'ladyb0i', 'ladyb0y', 'ladyboy', 'ladyboys', 'ladyboyz', 'lesbo', 'm0f0', 'm0f0s', 'm0fo', 'm0foes', 'm0fos', 
	'm0ng0l0id', 'm0ngoloid', 'm0thafucked', 'm0thafucker', 'm0thafucking', 'm0therfuckeds', 'm0therfucker', 'm0therfucking', 'm0therfvcker', 'markasses', 'mfckers', 
	'MFer', 'MFers', 'mfing', 'mfk', 'mfs', 'mfukk', 'mfukker', 'milf', 'mindfuck', 'mof0es', 'mof0s', 'mofcker', 'mofo', 'mofoes', 'mofos', 'mofoshit', 'mofuccers', 
	'mofucckers', 'mofuck', 'mofucker', 'mofuckkas', 'mofuk', 'mofukkas', 'molester', 'mong', 'mongoloid', 'mongrel', 'mothafcked', 'mothafcking', 'Mothafucc', 
	'mothafucced', 'mothafuccer', 'mothafuccing', 'mothafuck', 'mothafucka', 'mothafuckas', 'mothafuckasses', 'mothafuckaz', 'mothafuckazzes', 'mothafucked', 
	'mothafuckeds', 'mothafucker', 'mothafuckers', 'mothafuckin', 'mothafucking', 'mothafuckings', 'mothafuckins', 'mothafucks', 'mothafuckz', 'mothafvcked', 
	'mothercker', 'motherfacking', 'motherfcked', 'motherfckin', 'motherfcking', 'motherfcks', 'motherfckshit', 'motherfecka', 'motherfecker', 'motherfk', 
	'motherfucca', 'motherfuccas', 'motherfuccers', 'motherfuck', 'motherfucked', 'motherfuckeds', 'motherfucker', 'motherfuckers', 'motherfuckin', 'motherfucking', 
	'motherfuckings', 'motherfuckingshit', 'motherfuckins', 'motherfuckka', 'motherfuckkas', 'motherfuckkers', 'motherfucks', 'motherfukka', 'motherfukker', 
	'motherfukkings', 'motherfvck', 'motherfvcked', 'motherfvckeds', 'motherfvcker', 'motherfvckers', 'motherfvcking', 'motherfxck', 'motherfxcking', 'mothfck', 
	'mtherfuker', 'mthrfcker', 'muddafukkas', 'mudderfuk', 'mudderfukker', 'mufdive', 'mufdivin', 'muff', 'muffdiving', 'muffdivings', 'muffindivin', 'muffindiving', 
	'muhfucking', 'muthafecker', 'muthafeckers', 'muthafucka', 'muthafuckers', 'muthafuckings', 'muthafuckker', 'muthafuckkers', 'muthafukka', 'mutherfucker', 
	'mutherfuckers', 'n0bhead', 'n0bj0cky', 'n1ckker', 'n1g3r', 'n1g3rz', 'n1gg3r', 'n1gg3rs', 'n1gga', 'n1ggah', 'n1ggahs', 'n1ggas', 'n1ggazes', 'n1gger', 
	'n1ggers', 'n1gguh', 'n3gro', 'negga', 'neggar', 'negr0', 'negro', 'negroes', 'negroid', 'niccer', 'nicka', 'nickas', 'nicker', 'nickk3r', 'nickker', 'nig', 
	'niga', 'nigah', 'nigasses', 'nigers', 'nigg3r', 'nigg3rs', 'nigg4h', 'nigg4hs', 'nigga', 'niggah', 'niggahs', 'niggahz', 'niggas', 'niggass', 'niggaz', 
	'niggazzes', 'nigger', 'niggers', 'niggerz', 'niggir', 'niggress', 'nigguh', 'nigguhs', 'nigguhz', 'niglet', 'nignigs', 'nignog', 'nigra', 'nigre', 'nigs', 
	'niguh', 'nikk3r', 'nikkas', 'nikker', 'nip', 'nobbyhead', 'nobhead', 'nobheads', 'nobj0key', 'nobjockies', 'nobjocky', 'nobjokey', 'nobjokeys', 'nobs', 'nonce', 
	'nuckas', 'nuggets', 'nutsack', 'nutsacks', 'nympho', 'nymphomaniac', 'octopussy', 'p3n1shead', 'p3nisfcker', 'p3nisfcukers', 'p3nisfvcker', 'p3nisfvckers', 
	'packerfudgehead', 'packingfudge', 'packingfudgefucker', 'packingfudgefucking', 'packsomefudgefucker', 'paki', 'pecker', 'peckerhead', 'pedo', 'pedobear', 
	'pedobears', 'pedophl', 'pedos', 'pedoz', 'peen', 'peener', 'penisfcker', 'penisfuccer', 'penisfucker', 'penisfuckers', 'penisfvcker', 'penisfvckers', 
	'penishead', 'peter', 'phaggot', 'phaggots', 'phagot', 'phags', 'phuc', 'phucc', 'phuccer', 'phucchead', 'phuccing', 'phuck', 'phuck3r', 'phucked', 'phucker', 
	'phuckin', 'phucking', 'phuckings', 'phucks', 'phucup', 'phuk', 'phuked', 'phukeds', 'phukhead', 'phuking', 'phukings', 'phukk', 'phukked', 'phukkeds', 'phukker', 
	'Phukking', 'phuks', 'phukshit', 'phuku', 'phukup', 'phuq', 'phuqs', 'phvckings', 'pigfucker', 'pigfuckers', 'pigfucking', 'pigfukker', 'piggyfuck', 'pigshit', 
	'pissoff', 'pissoffs', 'polesmoker', 'prick', 'pricks', 'pu55y', 'punani', 'punkasses', 'puss', 'pusses', 'pussie', 'pussies', 'pussless', 'pusslicker', 'pussy', 
	'pussylickers', 'pussys', 'pussywhipped', 'puta', 'puussy', 'puzzies', 'puzzy', 'queerasses', 'queers', 'r3tard', 'raghead', 'ragheads', 'ragtard', 'ramrod', 
	'reacharound', 'rectum', 'redskin', 'retard', 'retardo', 'retardotron', 'sack', 'sambo', 'scamfuck', 'schlong', 'scumfuck', 'scumfucker', 'scumfvck', 'scummy', 
	'scut', 'sh1s', 'sh1t', 'sh1t3', 'sh1td1ck', 'sh1tdick', 'sh1te', 'sh1tfuck', 'sh1th3ad', 'sh1theads', 'sh1ts', 'sh1tsome', 'sh1tt', 'sh1tty', 'sh3mal3', 
	'sh3male', 'shat', 'sheeeet', 'sheet', 'sheister', 'shemal3', 'shemale', 'shemales', 'shet', 'shiat', 'shiddick', 'shiester', 'shiesterfuck', 'shiesterfuckface', 
	'shiesterfuckhead', 'shiesterfucks', 'shipdit', 'shit', 'shit3', 'shitass', 'shitasses', 'shitassfucker', 'shitassfuckface', 'shitbag', 'shitbird', 'shitblimp', 
	'shitblimps', 'shitbrain', 'shitd1ck', 'shitdick', 'shitdicks', 'shitdikk', 'shitdip', 'shite', 'shiteblimps', 'shited', 'shitedick', 'shitefuck', 'shitefulls', 
	'shitehead', 'shites', 'shitey', 'shitface', 'shitfaced', 'shitfacefuck', 'shitfacefucker', 'shitfck', 'shitfk', 'shitfreak', 'shitfuck', 'shitfucker', 
	'shitfuckhead', 'shitfuckmotherfucker', 'shitfucks', 'shitfudgefucker', 'shitfvck', 'shithead', 'shitheadfucker', 'shitheadfuckface', 'shitheads', 'shithole', 
	'shits', 'shitsdick', 'shitsfuck', 'shitsful', 'shittastic', 'shittasticfuck', 'shitte', 'shitted', 'shitter', 'shitterfucker', 'shitti', 'shitties', 'shittiest', 
	'shitting', 'shittings', 'shitty', 'shittydick', 'shittydicks', 'shittyfuck', 'shittyfuckface', 'shittyful', 'shlong', 'shmale', 'shtfuk', 'shylock', 
	'shytfeisterfuck', 'sissy', 'skank', 'skanks', 'skanky', 'skankz', 'slag', 'slantard', 'slanteye', 'slanteyes', 'slanteyeshit', 'slantfreak', 'slanty', 'slit', 
	'slut', 'sluts', 'slutty', 'snatch', 'soab', 'sonofabitch', 'sonofbitches', 'spanking', 'sperm', 'sphincter', 'spic', 'spicfuck', 'spick', 'spics', 'spicshit', 
	'spig', 'spik', 'spix', 'spook', 'spooks', 'spunk', 'stfu', 'stupidasses', 'suck', 'sumbitch', 'swine', 'tacohead', 'tadger', 'tallywacker', 'tard', 'tart', 
	'throater', 'tits', 'tosser', 'towelhead', 'towelheads', 'towelshithead', 'tramp', 'Tranny', 'transvestite', 'trashb1tch', 'trashbitch', 'trashbitches', 
	'trashbitchez', 'trashbtch', 'trasherbitch', 'trasherbitchs', 'trashybitches', 'trousersnake', 'turdcutter', 'turdhead', 'twat', 'twatface', 'twats', 'twatt', 
	'twattish', 'twatzilla', 'twink', 'upskirts', 'vag', 'vajayjay', 'vulva', 'w4nk3r', 'w4nker', 'wang', 'wank', 'wank3r', 'wank3rs', 'wankbastard', 'wanked', 
	'wanker', 'wankers', 'wankies', 'wanking', 'wanks', 'we1back', 'weenie', 'weiner', 'wetback', 'wetbacks', 'wh0r3', 'wh0re', 'whoar', 'whoars', 'whor3', 'whore', 
	'whores', 'wigger', 'wnker', 'wop', 'wophead', 'zipperhead', 'fuck', 'sex', 'orgasm', 'ejaculation', 'foreskin', 'abraham', 'abo', 'ape', 'wound', 'bang', 
	'masturbate', 'meat', 'blumpkin', 'bonk', 'breast', 'bum', 'bung', 'butt', 'cojones', 'testicles', 'choad', 'clit', 'cum', 'dick', 'dildo', 'fellatio', 'gay', 
	'damn', 'hell', 'grope', 'gypsy', 'hebe', 'homosexual', 'jerk', 'jew', 'kidtoucher', 'lesbian', 'loose', 'molest', 'niggger', 'nipple', 'nymph', 'penis', 
	'pedophile', 'piss', 'punta', 'queer', 'retarded', 'monkey', 'sadomasochism', 'ballsack', 'scum', 'spank', 'tit', 'tranny', 'turd', 'upskirt', 'vagina', 'fart', 
	'hag', 'pig', 'trash', 'boiolas'];

/** User Management Functions
 * Grouping all functions related to user management.
 */
const userManagement = {
	/** Cache object to store user profiles and timestamp for caching purposes.
	 * @typedef {Object} Cache
	 */
	cache: {
		rooms: null,
		profiles: null,
		roomsTimestamp: null,
		profilesTimestamp: null
	},

	/** Stored room data for each chatroom with active users
	 * @typedef {Object} roomData Cache
	 */
	roomData: {
		roomUsers: {},
		senderStream: {},
		activeSpeakers: new Map(),
		approvalRequests: [],
		userMsgTimestamps: {},
		userPokeTimestamps: {},
		userActivityTimeouts: {}
	},

	fetchRoomData : () => userManagement.roomData,

	/** Check if the maximum number of broadcasters has been reached.
	 * @param {string} roomId - Room ID.
	 * @returns {boolean} - True if the limit is reached, false otherwise.
	 */
	maxBroadcastersCheck: (roomId) => userManagement.roomData.senderStream[roomId]?.length >= userManagement.isVip({ room: { name: roomId } }).streamsLimit,
	
	/** Detects if there are repeating characters or words.
	 * @param {string} username - The username to check for repetition.
	 * @returns {boolean} - Returns true if repetition is detected, false otherwise.
	 */
	detectRepetition: (username) => {
		const repeatedChars = /(.)\1{4,}/;
		const repeatingWords = /(\b\w+\b)\s*\1{3,}/;
		const words = username.split(/[^a-zA-Z0-9]/).filter(Boolean);
		const wordCounts = words.reduce((counts, word) => {
			word = word.toLowerCase();
			counts[word] = (counts[word] || 0) + 1;
			return counts;
		}, {});
		for (let word in wordCounts) {
			if (wordCounts[word] > 3 && !commonWords.includes(word)) return true;
		}
		return repeatedChars.test(username) || repeatingWords.test(username);
	},

	/** Cleans sensitive or unnecessary data from the user object.
	 * @param {Object} user - The user object to be cleaned.
	 * @returns {Object} - The cleaned user object.
	 */
	cleanUserData: (user = {}) => ({
		id: 						user.id || null,
		uuid: 						user.id || null,
		self: 						user.self || false,
		isVip: 						user.isVip || false,
		privacy: 					user.privacy || false,
		chatrooms: 					user.chatrooms || false,
		twoFactorEnabled: 			user.twoFactorEnabled || false,
		notifcationSounds: 			user.notifcationSounds || false,
		bio: 						user.bio || '',
		role: 						user.role || 'member',
		status: 					user.status || 'online',
		username: 					user.username || 'Unknown',
		profilePhoto: 				user.profilePhoto || '/images/user-avatar.png',
		joinDate: 					user.joinDate || new Date().toISOString(),
		roomsAccess: 				user.roomsAccess || { ['Lobby']: true },
		following: 					user.following || [],
		blocked: 					user.blocked || [],
		credits: {
			amount: 				user.credits?.amount || 0,
			lastTransactionDate: 	user.credits?.lastTransactionDate || null
		}
	}),

	/** Updates the user session data by comparing the current user object with the differs object.
	 * @param {Object} user - The current user session object.
	 * @param {Object} differs - actual database info.
	 * @returns {Object} - The updated user object with any changes applied.
	 */
	updateUserSessionData: (user, differs, sessionCsrfToken) => {
		const updatedUser = {
			id: 						(differs.id !== user.id) ? differs.id : user.id || null,
			uuid: 						(differs.id !== user.uuid) ? differs.id : user.uuid || null,
			captcha: 					user.captcha || null,
			csrfToken: 					sessionCsrfToken || null,
			self: 						(differs.self !== user.self) ? differs.self : user.self || false,
			isVip: 						(differs.isVip !== user.isVip) ? differs.isVip : user.isVip || false,
			isGuest: 					(differs.isGuest !== user.isGuest) ? differs.isGuest : user.isGuest || true,
			privacy: 					(differs.privacy !== user.privacy) ? differs.privacy : user.privacy || false,
			twoFactorEnabled: 			(differs.twoFactorEnabled !== user.twoFactorEnabled) ? differs.twoFactorEnabled : user.twoFactorEnabled || false,
			notifcationSounds: 			(differs.notifcationSounds !== user.notifcationSounds) ? differs.notifcationSounds : user.notifcationSounds || false,
			bio: 						(differs.bio !== user.bio) ? differs.bio : user.bio || '',
			role: 						(differs.role !== user.role) ? differs.role : user.role || 'guest',
			status: 					(differs.status !== user.status) ? differs.status : user.status || 'online',
			username: 					(differs.username !== user.username) ? differs.username : user.username || 'Unknown',
			profilePhoto: 				(differs.profilePhoto !== user.profilePhoto) ? differs.profilePhoto : user.profilePhoto || '/images/user-avatar.png',
			joinDate: 					(differs.joinDate !== user.joinDate) ? differs.joinDate : user.joinDate || new Date().toISOString(),
			roomsAccess: 				(differs.roomsAccess !== user.roomsAccess) ? differs.roomsAccess : user.roomsAccess || {},
			chatrooms: 					(differs.chatrooms !== user.chatrooms) ? differs.chatrooms : user.chatrooms || false,
			following: 					(differs.following !== user.following) ? differs.following : user.following || [],
			blocked: 					(differs.blocked !== user.blocked) ? differs.blocked : user.blocked || [],
			credits: {
				amount: 				(differs.credits?.amount !== user.credits?.amount) ? differs.credits?.amount : user.credits?.amount || 0,
				lastTransactionDate: 	(differs.credits?.lastTransactionDate !== user.credits?.lastTransactionDate) ? differs.credits?.lastTransactionDate : user.credits?.lastTransactionDate || null
			}
		};
		return updatedUser;
	},

	/** Cleans profile data for rendering, limiting the amount of data .
	 * @param {Array} profiles - Array of user profile objects.
	 * @param {Object} loggedInUser - The currently logged in user, to check following status.
	 * @returns {Array} - The cleaned profile data array.
	 */
	cleanProfileData: (profiles, loggedInUser = null) => profiles.map(profile => ({
        id: profile.id,
        isVip: profile.isVip,
        username: profile.username,
        joinDate: profile.joinDate,
        profilePhoto: profile.profilePhoto,
        followingCount: profile.following.length,
        bio: profile.bio ? profile.bio.slice(0, 50) : '',
        isFollowing: loggedInUser ? profile.following.includes(loggedInUser.id) : false
    })),

	/** Add a new user to the database.
	 * @param {string} username - Username of the new user.
	 * @param {string} password - Password of the new user.
	 * @param {string} email - Email of the new user.
	 * @param {string} phone - Phone number of the new user.
	 * @param {string} firstName - First name of the new user.
	 * @param {string} lastName - Last name of the new user.
	 * @param {string} profilePhoto - Profile photo URL of the new user.
	 * @param {string} code - Verification code for the new user.
	 * @returns {Promise<Object>} - The created user object.
	 */
	addUser: async (username, password, email, phone, firstName, lastName, profilePhoto, privacy, code) => {
		try {
			const users = database.users || [];
			if (username && users.find(user => user.username === username)) throw new Error('Username already exists');
			if (phone && users.find(user => user.phone === phone)) throw new Error('Phone number already exists');
			if (userManagement.detectRepetition(username.toLowerCase()) && (restrictedNames.includes(username.toLowerCase()) || badWords.includes(username.toLowerCase())))  throw new Error('Username is a reserved name');
			const user = {
				id: QPRx2025.generateUUID(),
				username,
				password: QPRx2025.customHash(password, process.env.HASHUSERSALT || 10),
				email,
				phone,
				firstName,
				lastName,
				privacy,
				code,
				profilePhoto: profilePhoto || '/images/user-avatar.png',
				role: 'member',
				bio: '',
				joinDate: new Date(),
				notifcationSounds: false,
				twoFactorEnabled: false,
				approveAvatar: false,
				verified: false,
				isVip: false,
				games: true,
				roomsAccess: { ['Lobby']: true },
				following: [],
				blocked: [],
				credits: {
					amount: 0,
					lastTransactionDate: null,
					paymentDetails: {}
				}
			};
			users.push(user);
			writeDatabase({ ...database, users });
			return user;
		} catch (error) {
			handleError(error);
		}
	},

	/** Checks if the given date is within the last 30 days or if it is marked as 'expired'.
	 * @param {string|Date} date - The date to check (should be a valid date string, Date object, or 'expired').
	 * @returns {boolean} - Returns true if the date is within the last 30 days; otherwise, false.
	 */
	isWithinLast30Days: (date) => {
		if (date === 'expired') return false;
		const now = new Date();
		const past30Days = new Date(now.setDate(now.getDate() - 30));
		return new Date(date) >= past30Days;
	},

	/** Checks if a room has VIP access based on donation status and handles payments.
	 * @param {Object} data - The user data containing donation, lastDonationDate, and room information.
	 * @param {number} [data.donation=0] - The amount donated to the room (default is 0).
	 * @param {string|Date} [data.lastDonationDate='expired'] - The last donation date (valid date string, Date object, or 'expired').
	 * @param {number} [data.streamsLimit=12] - The streams limit for the room (default is 12).
	 * @param {Object} [data.room] - The room object containing room details.
	 * @param {Object} [data.newPayment] - The new payment object containing roomId and donationAmount.
	 * @param {Object} req - The request object for accessing session details.
	 * @returns {Object} - VIP status, iceServer configuration, and streams limit.
	 */
	isVip: async ({ room, donation = 0, lastDonationDate = 'expired', streamsLimit = 12, newPayment }, req) => {
		const isRoomVip = room?.vip || false;
		const vip = (donation > 10 && userManagement.isWithinLast30Days(lastDonationDate)) || isRoomVip;
		if (req && newPayment && newPayment.roomId && newPayment.donationAmount > 0) {
			try {
				const { user } = req.session || {};
				const isLogged = user && !user.isGuest && req.session.csrfToken;
				if (isLogged) await processRoomDonation(user.id, newPayment);
			} catch (error) {
				console.log(error);
			}
		}
		const VipTurnServer = 	process.env.VIP_TURN_SERVER_URL &&
								process.env.VIP_TURN_SERVER_USERNAME &&
								process.env.VIP_TURN_SERVER_CREDENTIAL;
		const turnServerConfig = (vip && VipTurnServer) ? {
			urls: 		process.env.VIP_TURN_SERVER_URL,
			username: 	process.env.VIP_TURN_SERVER_USERNAME,
			credential: process.env.VIP_TURN_SERVER_CREDENTIAL
		} : {
			urls: 		process.env.TURN_SERVER_URL || 			null,
			username: 	process.env.TURN_SERVER_USERNAME || 	null,
			credential: process.env.TURN_SERVER_CREDENTIAL || 	null
		};
		let finalStreamsLimit = vip ? 24 : streamsLimit;
		if (vip) {
			room.customSounds = {
				poke: 		room?.customSounds?.poke || 	null,
				role: 		room?.customSounds?.role || 	null,
				muted: 		room?.customSounds?.muted || 	null,
				kicked: 	room?.customSounds?.kicked || 	null,
				banned: 	room?.customSounds?.banned || 	null,
				joined: 	room?.customSounds?.joined || 	null,
				mention: 	room?.customSounds?.mention || 	null,
				followed: 	room?.customSounds?.followed || null
			};
		}
		return {
			iceServer: turnServerConfig,
			streamsLimit: finalStreamsLimit,
			iceCandidatePoolSize: finalStreamsLimit + 2
		};
	},

	/*
	Default Room Configuration
	const defaultConfig = isVip({ room: { name: roomId } }, req);

	VIP Room Configuration Based on Donations
	const vipConfig = isVip({ room: { name: roomId }, donation: 15, lastDonationDate: '2024-08-10' }, req);

	Handling New Payments to Update Room Settings
	const newDonation = { roomId: roomId, donationAmount: 50 };
	isVip({ room: { name: newDonation.roomId }, newPayment: newDonation }, req);
	*/

	/** Update a user's credits.
	 * @param {string} userId - ID of the user.
	 * @param {number} amount - Amount of credits to add.
	 * @param {string} paymentType - Type of payment method used.
	 * @param {Date} transactionDate - Date of the transaction.
	 * @returns {Promise<Object>} - Updated user object with credits.
	 */
	updateCredits: async (userId, amount, paymentType, transactionDate) => {
		try {
			const user = userManagement.findUserById(userId);
			if (!user) throw new Error('User not found');
			user.credits.amount += amount;
			user.credits.lastTransactionDate = transactionDate;
			user.credits.paymentDetails = {
				paymentType,
				amount,
				transactionDate,
			};
			writeDatabase({ ...database, users: database.users.map(u => u.id === userId ? user : u) });
			return user;
		} catch (error) {
			handleError(error);
		}
	},

	/** Handles the payment process for a user and updates their credits.
	 * @param {string} userId - ID of the user to update.
	 * @param {Object} paymentData - Object containing payment details.
	 * @param {number} paymentData.amount - Amount of credits to add.
	 * @param {string} paymentData.paymentType - Type of payment method used.
	 * @returns {Promise<void>} - Logs the updated user object to the console.
	 */
	handlePayment: async (userId, paymentData) => {
		try {
			const { amount, paymentType } = paymentData;
			const transactionDate = new Date();
			const updatedUser = await userManagement.updateCredits(userId, amount, paymentType, transactionDate);
			if (!updatedUser) throw new Error('Failed to update user credits');
			logActivity(userId, `User credits added: ${amount} for ${userId}`);
		} catch (error) {
			handleError(error);
		}
	},

	/** Checks and updates the room's VIP status based on donations.
	 * Transfers excess credits (beyond 365 days) to the room owner's account.
	 * @param {string} roomId - ID of the room.
	 * @param {number} donationAmount - Amount of credits donated.
	 * @returns {Promise<Object>} - Updated room object with new donation data.
	 */
	updateRoomDonation: async (roomId, donationAmount) => {
		try {
			const roomIndex = database.rooms.findIndex(room => room.id === roomId);
			if (roomIndex === -1) throw new Error('Room not found');
			const room = database.rooms[roomIndex];
			const maxDays = 365;
			room.donation = (room.donation || 0) + donationAmount;
			room.lastDonationDate = new Date().toISOString();
			const daysToAdd = Math.min(Math.floor(donationAmount / 10) * 30, maxDays);
			const newExpiryDate = new Date(room.lastDonationDate);
			newExpiryDate.setDate(newExpiryDate.getDate() + daysToAdd);
			room.lastDonationExpiryDate = newExpiryDate;
			if (daysToAdd >= maxDays) {
				const excessCredits = donationAmount - (maxDays / 30 * 10);
				if (excessCredits > 0) {
					const roomOwner = userManagement.findUserById(room.owner);
					if (roomOwner) {
						roomOwner.credits.amount += excessCredits;
						roomOwner.credits.lastTransactionDate = new Date().toISOString();
						logActivity(room.owner, `Transferred ${excessCredits} excess credits from room ${roomId} donation.`);
					}
				}
			}
			writeDatabase({ ...database, rooms: database.rooms.map(r => r.id === roomId ? room : r) });
			return room;
		} catch (error) {
			handleError(error);
		}
	},

	/** Adds credits from a user's account to a room's donation if the user has sufficient credits.
	 * @param {string} userId - ID of the user donating credits.
	 * @param {Object} paymentData - Payment details containing the donation amount and room ID.
	 * @param {number} paymentData.donationAmount - Amount of credits to donate.
	 * @param {string} paymentData.roomId - ID of the room receiving the donation.
	 * @returns {Promise<Object>} - Returns an updated user object with modified credits and donation log.
	 */
	addCreditsToRoomDonation: async (userId, paymentData) => {
		try {
			const { donationAmount, roomId } = paymentData;
			const user = userManagement.findUserById(userId);
			if (!user) throw new Error('User not found');
			if (user.credits.amount < donationAmount) throw new Error('Insufficient credits to make a donation');
			user.credits.amount -= donationAmount;
			user.credits.donations = user.credits.donations || {};
			user.credits.donations[roomId] = user.credits.donations[roomId] || [];
			user.credits.donations[roomId].push({
				donationAmount,
				transactionDate: new Date().toISOString(),
				roomId,
			});
			await userManagement.updateRoomDonation(roomId, donationAmount);
			writeDatabase({ ...database, users: database.users.map(u => u.id === userId ? user : u) });
			return user;
		} catch (error) {
			handleError(error);
		}
	},	

	/** Processes a user's room donation, updates their credits and the room's donation status.
	 * @param {string} userId - ID of the user donating credits.
	 * @param {Object} paymentData - Payment details containing the donation amount and room ID.
	 * @returns {Promise<Object>} - Updated user and room objects with modified credits and donation data.
	 */
	processRoomDonation: async (userId, paymentData, clean = false) => {
		try {
			const updatedUser = await userManagement.addCreditsToRoomDonation(userId, paymentData);
			if (!updatedUser) throw new Error('Failed to process room donation');
			logActivity(userId, `Donation processed: ${paymentData.donationAmount} credits to room ${paymentData.roomId}`);
			if (clean) updatedUser = userManagement.cleanUserData(updatedUser);
			return updatedUser;
		} catch (error) {
			handleError(error);
		}
	},	

	/** Find a user by id.
	 * @param {string} userId - userId to find.
	 * @returns {Object|false} - User object if found, otherwise false.
	 */
	findUserById: (userId, clean = false) => {
		if (!userId || typeof userId !== 'string') return false;
		const temp = database.users.find(user => user.id && user.id === userId);
		if (clean) temp = userManagement.cleanUserData(temp);
		return temp || false;
	},

	/** Find a user by username.
	 * @param {string} username - Username to find.
	 * @returns {Object|false} - User object if found, otherwise false.
	 */
	findUserByUsername: (username, clean = false) => {
		if (!username || typeof username !== 'string') return false;
		const temp = database.users.find(user => user.username && user.username.toLowerCase() === username.toLowerCase());
		if (clean) temp = userManagement.cleanUserData(temp);
		return temp || false;
	},

	/** Find a user by email or phone.
	 * @param {string} identifier - Email or phone to find.
	 * @returns {Object|false} - User object if found, otherwise false.
	 */
	findUserByEmailOrPhone: (identifier, clean = false) => {
		if (!identifier || typeof identifier !== 'string') return false;
		const temp = database.users.find(user => 
			(user.email && user.email.toLowerCase() === identifier.toLowerCase()) || 
			(user.phone && user.phone === identifier)
		);
		if (clean) temp = userManagement.cleanUserData(temp);
		return temp || false;
	},

	/** Find a user by email.
	 * @param {string} email - Email to find.
	 * @returns {Object|false} - Email object if found, otherwise false.
	 */
	findUserByEmail: (email, clean = false) => {
		if (!email || typeof email !== 'string') return false;
		const temp = database.users.find(user => user.email && user.email.toLowerCase() === email.toLowerCase());
		if (clean) temp = userManagement.cleanUserData(temp);
		return temp || false;
	},

	/** Verify the email token.
	 * @param {string} token - The token to verify.
	 * @returns {Promise<void>} - Resolves if the token is valid.
	 */
	verifyEmailToken: async (token) => {
		try {
			const userIndex = database.users.findIndex(user => user.code === token);
			if (userIndex !== -1) {
				database.users[userIndex].verified = true;
				database.users[userIndex].code = '';
				writeDatabase(database);
			} else throw new Error('Invalid or expired token');
		} catch (error) {
			handleError(error);
		}
	},

	/** Verify the user's account by setting the verified field to true.
	 * @param {string} userId - ID of the user to verify.
	 * @returns {Promise<void>}
	 */
	verifyUserAccount: async (userId) => {
		try {
			const userIndex = database.users.findIndex(user => user.id === userId);
			if (userIndex !== -1) {
				database.users[userIndex].verified = true;
				writeDatabase(database);
			} else throw new Error('User not found');
		} catch (error) {
			handleError(error);
		}
	},

	/** Verify the phone code.
	 * @param {string} phone - The phone number to verify.
	 * @param {string} code - The code to verify.
	 * @returns {Promise<void>} - Resolves if the code is valid.
	 */
	verifyPhoneCode: async (phone, code) => {
		try {
			const userIndex = database.users.findIndex(user => user.phone === phone && user.code === code);
			if (userIndex !== -1) {
				database.users[userIndex].verified = true;
				database.users[userIndex].code = '';
				writeDatabase(database);
			} else throw new Error('Invalid or expired code');
		} catch (error) {
			handleError(error);
		}
	},

	/** Reset the user's password using a token.
	 * @param {string} token - The token to verify.
	 * @param {string} hashedPassword - The new hashed password.
	 * @returns {Promise<void>} - Resolves if the password is reset.
	 */
	resetPassword: async (token, hashedPassword) => {
		try {
			const userIndex = database.users.findIndex(user => user.code === token);
			if (userIndex !== -1) {
				database.users[userIndex].password = hashedPassword;
				database.users[userIndex].code = '';
				writeDatabase(database);
			} else throw new Error('Invalid or expired token');
		} catch (error) {
			handleError(error);
		}
	},

	/** Generate a secure random token for user verification.
	 * @returns {string} - A secure random token.
	 */
	generateToken: () => {
		QPRx2025.init(Date.now());
		return QPRx2025.lcg().toString(36).substr(2);
	},
	
	/** Verify if the user's account has games enabled.
	 * @param {string} userId - ID of the user to verify.
	 * @returns {Promise<boolean>} - A promise that resolves to true if games are enabled, otherwise false.
	 */
	verifyUserEnabledGames: async (userId) => {
		try {
			const user = database.users.find(user => user.id === userId);
			if (user) return user.games || false;
			else throw new Error('User not found');
		} catch (error) {
			handleError(error);
			return false;
		}
	},

	/** Update a user's profile.
	 * @param {string} userId - ID or username of the user.
	 * @param {Object} profileUpdates - Profile updates object.
	 * @returns {Promise<Object>} - Updated user object.
	 */
	updateUserProfile: async (userId, profileUpdates) => {
		try {
			let user = database.users.find(user => user.id === userId || user.username === userId);
			if (!user) throw new Error('User not found');
			Object.assign(user, profileUpdates);
			writeDatabase(database);
			return user;
		} catch (error) {
			handleError(error);
		}
	},

	/** Delete a user by ID.
	 * @param {string} userId - ID of the user to delete.
	 * @param {string} adminId - ID of the admin requesting the delete.
	 * @returns {Promise<void>}
	 */
	deleteUser: async (userId, adminId) => {
		try {
			const admin = database.users.find(user => user.id === adminId && user.role === 'developer');
			if (!admin) throw new Error('Permission denied');
			const updatedUsers = database.users.filter(user => user.id !== userId);
			if (updatedUsers.length === database.users.length) throw new Error('User not found');
			database.users = updatedUsers;
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Shadow ban a user by ID.
	 * @param {string} userId - ID of the user to shadow ban.
	 * @param {string} adminId - ID of the admin requesting the shadow ban.
	 * @returns {Promise<void>}
	 */
	shadowBanUser: async (userId, adminId) => {
		try {
			const admin = database.users.find(user => user.id === adminId && user.role === 'developer');
			if (!admin) throw new Error('Permission denied');
			const userIndex = database.users.findIndex(user => user.id === userId);
			if (userIndex !== -1) {
				database.users[userIndex].shadowBanned = true;
				writeDatabase(database);
			} else throw new Error('User not found');
		} catch (error) {
			handleError(error);
		}
	},

	/** Enable two-factor authentication for a user.
	 * @param {string} userId - ID of the user.
	 * @returns {Promise<void>}
	 */
	enable2FA: async (userId) => {
		try {
			const userIndex = database.users.findIndex(user => user.id === userId);
			if (userIndex !== -1) {
				database.users[userIndex].twoFactorEnabled = true;
				writeDatabase(database);
			} else throw new Error('User not found');
		} catch (error) {
			handleError(error);
		}
	},

	/** Disable two-factor authentication for a user.
	 * @param {string} userId - ID of the user.
	 * @returns {Promise<void>}
	 */
	disable2FA: async (userId) => {
		try {
			const userIndex = database.users.findIndex(user => user.id === userId);
			if (userIndex !== -1) {
				database.users[userIndex].twoFactorEnabled = false;
				writeDatabase(database);
			} else throw new Error('User not found');
		} catch (error) {
			handleError(error);
		}
	},

	/** Validate role change operation.
	 * @param {Object} admin - The admin user object.
	 * @param {Object} user - The user object.
	 * @param {string} role - The new role to assign.
	 * @param {Object} room - The room object.
	 */
	validateRoleChange: (admin, user, role, room) => {
		const disallowedRoles = ['guest', 'member', 'moderator', 'admin', 'owner', 'developer'];
		if (disallowedRoles.includes(role)) throw new Error('Cannot change to this role');
		if (!admin || !user || !room) throw new Error('Invalid admin, user, or room');
		if (room.owner !== admin.id && !room.admins.includes(admin.id) && admin.role !== 'super' && admin.role !== 'developer') throw new Error('Permission denied');
	},

	/** Change the role of a user.
	 * @param {string} adminId - ID of the admin changing the role.
	 * @param {string} userId - ID of the user whose role is being changed.
	 * @param {string} role - New role for the user.
	 * @param {string} roomId - ID of the room where the role is being changed.
	 * @returns {Promise<Object>} - The updated user object.
	 */
	changeUserRole: async (adminId, userId, role, roomId, clean = false) => {
		try {
			const admin = database.users.find(user => user.id === adminId);
			const user = database.users.find(user => user.id === userId);
			const room = database.rooms[roomId];
			userManagement.validateRoleChange(admin, user, role, room);
			const roleExists = room.roles.find(roomRole => roomRole.roleName === role);
			if (!roleExists) throw new Error('Role does not exist in this room');
			const userInRoom = room.users.includes(user.id);
			if (!userInRoom) throw new Error('User is not a member of this room');
			user.role = role;
			logActivity(admin.id, `Changed role of user ${user.username} to ${role} in room ${room.name}`, roomId);
			writeDatabase(database);
			if (clean) user = userManagement.cleanUserData(user);
			return user;
		} catch (error) {
			handleError(error);
		}
	},

	/** Assign a role to a user.
	 * @param {string} adminId - ID of the admin.
	 * @param {string} userId - ID of the user.
	 * @param {string} role - Role to assign.
	 * @param {string} roomId - ID of the room.
	 * @returns {Promise<void>}
	 */
	assignRole: async (adminId, userId, role, roomId) => {
		try {
			const admin = database.users.find(user => user.id === adminId);
			const user = database.users.find(user => user.id === userId);
			const room = database.rooms[roomId];
			const disallowedRoles = ['developer'];
			if (!admin || !user || !room) throw new Error('Invalid admin, user, or room');
			if (disallowedRoles.includes(role)) throw new Error('Cannot assign this role');
			if (room.owner !== admin.id && !room.admins.includes(admin.id) && admin.role !== 'super' && admin.role !== 'developer') throw new Error('Permission denied');
			user.role = role;
			if (role === 'admin' && !room.admins.includes(user.id)) room.admins.push(user.id);
			logActivity(admin.id, `Assigned role ${role} to user ${user.username} in room ${roomId}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Remove a role from a user.
	 * @param {string} adminId - ID of the admin.
	 * @param {string} userId - ID of the user.
	 * @param {string} role - Role to remove.
	 * @param {string} roomId - ID of the room.
	 * @returns {Promise<void>}
	 */
	removeRole: async (adminId, userId, role, roomId) => {
		try {
			const admin = database.users.find(user => user.id === adminId);
			const user = database.users.find(user => user.id === userId);
			const room = database.rooms[roomId];
			if (!admin || !user || !room) throw new Error('Invalid admin, user, or room');
			if (room.owner !== admin.id && !room.admins.includes(admin.id) && admin.role !== 'super' && admin.role !== 'developer') throw new Error('Permission denied');
			user.role = 'member';
			if (role === 'admin') room.admins = room.admins.filter(id => id !== user.id);
			logActivity(admin.id, `Removed role ${role} from user ${user.username} in room ${roomId}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Confirm the transfer of room ownership.
	 * @param {string} currentOwnerId - ID of the current owner.
	 * @param {string} newOwnerId - ID of the new owner.
	 * @param {string} roomId - ID of the room.
	 * @returns {Promise<void>}
	 */
	confirmOwnershipTransfer: async (currentOwnerId, newOwnerId, roomId) => {
		try {
			const room = database.rooms[roomId];
			const newOwner = database.users.find(user => user.id === newOwnerId);
			if (!room || room.owner !== currentOwnerId || !newOwner) throw new Error('Invalid room, current owner, or new owner');
			room.owner = newOwnerId;
			if (!room.admins.includes(newOwnerId)) room.admins.push(newOwnerId);
			logActivity(currentOwnerId, `Transferred ownership of room ${roomId} to ${newOwner.username}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Update non-critical room settings.
	 * @param {string} roomId - ID of the room.
	 * @param {Object} settings - New settings for the room.
	 * @param {string} userId - ID of the user attempting to update the settings.
	 * @returns {Promise<void>}
	 */
	updateNonCriticalSettings: async (roomId, settings, userId) => {
		try {
			const room = database.rooms[roomId];
			const nonCriticalSettings = ['slowMode', 'contentProtection', 'allowGuests', 'topic'];
			const filteredSettings = {};
			if (!room || (room.owner !== userId && !room.admins.includes(userId) && userId !== 'super' && userId !== 'developer')) throw new Error('Permission denied');
			for (const key of nonCriticalSettings) {
				if (key in settings) filteredSettings[key] = settings[key];
			}
			Object.assign(room.settings, filteredSettings);
			logActivity(userId, `Updated non-critical settings for room ${roomId}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Create a new role within a room.
	 * @param {string} roomId - ID of the room.
	 * @param {string} roleName - Name of the new role.
	 * @param {Array} permissions - Permissions for the new role.
	 * @param {Object} settings - Settings for the role (e.g., colors).
	 * @param {string} adminId - ID of the admin creating the role.
	 * @returns {Promise<void>}
	 */
	createRole: async (roomId, roleName, permissions, settings, adminId) => {
		try {
			const room = database.rooms[roomId];
			const disallowedRoles = ['guest', 'member', 'moderator', 'admin', 'owner', 'developer'];
			if (!room || (room.owner !== adminId && !room.admins.includes(adminId) && admin.role !== 'super')) throw new Error('Permission denied');
			if (disallowedRoles.includes(roleName)) throw new Error('Cannot create this role');
			if (room.roles.some(role => role.roleName === roleName)) throw new Error('Role already exists');
			room.roles.push({ roleName, permissions, settings });
			logActivity(adminId, `Created role ${roleName} in room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Delete a role within a room.
	 * @param {string} roomId - ID of the room.
	 * @param {string} roleName - Name of the role to delete.
	 * @param {string} adminId - ID of the admin deleting the role.
	 * @returns {Promise<void>}
	 */
	deleteRole: async (roomId, roleName, adminId) => {
		try {
			const room = database.rooms[roomId];
			const disallowedRoles = ['guest', 'member', 'moderator', 'admin', 'owner', 'developer'];
			if (!room || (room.owner !== adminId && !room.admins.includes(adminId) && admin.role !== 'super')) throw new Error('Permission denied');
			if (disallowedRoles.includes(roleName)) throw new Error('Cannot delete this role');
			room.roles = room.roles.filter(role => role.roleName !== roleName);
			logActivity(adminId, `Deleted role ${roleName} in room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	}
};

/** Room Management Functions
 * Grouping all functions related to room management.
 */
const roomManagement = {
	/**
	 * Determine the role of the user based on their existing role or provided roleType.
	 * @param {string} username - The username of the user.
	 * @param {string} roleType - The role type of the user (guest or member).
	 * @param {Array} roomUsers - The list of users in the room.
	 * @returns {string} - The determined role of the user.
	 */
	determineUserRole: (username, roleType, roomUsers) => {
		const allowedRoles = ['member', 'moderator', 'super', 'admin', 'owner'];
		let userRole = roleType === 'guest' ? 'guest' : 'member';
		const existingUser = database.users.find(u => u.username === username);
		if (existingUser && existingUser.role === 'developer') return 'developer';
		const roomsUser = roomUsers.find(user => user.username === username);
		if (roomsUser && allowedRoles.includes(roomsUser.role)) userRole = roomsUser.role;
		return userRole;
	},
	/**
	 * Check the role of a user in a specific room.
	 * @param {string} roomId - The ID of the room to check.
	 * @param {Object} user - The user object data whose role to check.
	 * @returns {string} - The role of the user in the room, or 'member' if the user is found without a specific role, or 'guest' if not found.
	 * @throws {Error} If the room does not exist or the user has insufficient permissions.
	 */
	checkRole: async (roomId, user) => {
		try {
			const room = database.rooms[roomId];
			if (!room) throw new Error('Room not found');
			const userId = user.username;
			if (user.role === 'developer') return 'developer';
			if (room.owner === userId) return 'owner';
			if (room.admins.includes(userId)) return 'admin';
			const member = room.members.find(m => m.userId === user.id);
			if (member && room.memberAllowedRoles.includes(member.role)) return member.role;
			if (room.allowedRoles.includes(userId)) return room.allowedRoles[userId];
			return member ? 'member' : 'guest';
		} catch (error) {
			handleError(error);
		}
	},
	/*
	checkRole: async (roomId, user) => {
		try {
			const room = database.rooms[roomId];
			if (!room) throw new Error('Room not found');
			const userId = user.username;
			if (room.owner === userId) return 'owner';
			if (room.admins.includes(userId)) return 'admin';
			const member = room.members.find(m => m.userId === userId);
			if (member && room.memberAllowedRoles.includes(member.role)) return member.role;
			if (room.allowedRoles.includes(userId)) return room.allowedRoles[userId];
			return null;
		}
		catch (error) {
			handleError(error);
		}
	},
	*/
	/** Retrieve the list of all users in the database.
	 * @returns {Array} - An array of user objects present in the database, or an empty array if none exist.
	 */
	checkUsers: () => database.users || [],
	
	/** Check the existence and details of a room by its ID.
	 * @param {string} roomId - The ID of the room to check.
	 * @returns {Object|false} - The room object if found, or false if the room does not exist.
	 */
	checkRoom: roomId => database.rooms[roomId] || false,
	
	/** Check the existence and details of a rooms owned by username.
	 * @param {string} ownerId - The ID of the owner to check.
	 * @returns {Object|false} - The rooms found object, or false if the ownerId results 0.
	 */
	checkOwnedRoom: ownerId => Object.values(database.rooms).filter(room => room.owner === ownerId) || false, //add findUserById or name and fetch true id

	//returnRooms: () => database.rooms || [],
	//returnRooms: () => Object.fromEntries(Object.entries(database.rooms || {}).map(([id, { iceServer, streamsLimit, iceCandidatePoolSize, ...room }]) => [id, room])),
	/** Return the rooms object array and details of all rooms.
     * Cleans up unnecessary or sensitive data.
     * @returns {Object|Array} - The cleaned rooms object array, or an empty array if no rooms exist.
     */
    returnRooms: () => Object.fromEntries(Object.entries(database.rooms || {}).map(([id, { 
        iceServer,
        iceCandidatePoolSize,
        lastDonationDate,
        allowedRoles,
        mutedUsers,
        messages,
        settings,
        roles,
        ...room
    }]) => {
        const cleanedRoom = { ...room };
        roomManagement.adjustRoomData(cleanedRoom, room);
        return [id, cleanedRoom];
    })),

    /** Adjust the room data by adding calculated user count and donation status.
     * @param {Object} room - The room object to be cleaned.
     * @param {Object} data - The object where additional calculated properties will be added.
     * @returns {Object} - The updated room object with the cleaned data.
     */
    adjustRoomData: (room, data = {}) => {
        data.users = room.users ? room.users.length : 0;
        data.donation = room.donation >= 100 || false;
        return data;
    },

	/** Updates the room data in the database with the specified room details.
	 * @param {string} roomId - The ID of the room to update.
	 * @param {Object} room - The room object containing updated data to be merged with the existing room data.
	 * @returns {void}
	 */
	updateRoomDataGame: (roomId, room) => {
		if (!database.rooms[roomId]) return;
		database.rooms[roomId] = { ...database.rooms[roomId], ...room };
		writeDatabase(database);
		const gameData = database.rooms[roomId]?.gameInstances[roomId]; 
		logActivity(roomId, `Activity on room ${roomId}. Current game state: ${gameData?.getGameState()}`, roomId);  //may change roomId, ? , ?
	},
	
	/** Updates the room data in the database with the specified room details.
	* @param {string} roomId - The ID of the room to update.
	* @param {Object} room - The room object containing updated data to be merged with the existing room data.
	* @returns {void}
	*/
	updateRoomData: (roomId, room) => {
		if (!database.rooms[roomId]) return;
		database.rooms[roomId] = { ...database.rooms[roomId], ...room };
		writeDatabase(database)
	},

	/** Create a new room.
	 * @param {string} roomName - Name of the new room.
	 * @param {Object} settings - Settings for the new room.
	 * @param {string} ownerId - ID of the owner of the new room.
	 * @returns {string} - ID of the created room.
	 */
	createRoom: async (roomName, settings, ownerId) => {
		if (!roomName || !ownerId) throw new Error('Field is empty and required!');
		if (restrictedNames.includes(roomName.toLowerCase()) || badWords.includes(roomName.toLowerCase())) throw new Error('Room name contains restricted or inappropriate content.');
		const roomId = QPRx2025.generateUUID();
		const existingRoom = Object.values(database.rooms).find(room => room.name.toLowerCase() === roomName.toLowerCase());
		if (existingRoom) throw new Error('Room name already exists!');
		const ownerRooms = Object.values(database.rooms).filter(room => room.owner === ownerId);
		if (ownerRooms.length >= 3) throw new Error('You have reached the limit of 3 rooms.');
		userManagement.updateUserProfile(ownerId, { allowedRooms: { [roomName]: true } });
		database.rooms[roomName.toLowerCase()] = {
			id: roomId,
			name: roomName,
			owner: ownerId,
			topic: '',
			settings, 
			suspendedUsers: [],
			mutedUsers: [],
			messages: [],
			admins: [],
			roles: [], // { roleName, permissions, settings } settings =  color of role, permissions = control over room settings in future like youtube api
			users: [],
			vip: false,
			locked: false,
			slowMode: false,
			allowGuests: false,
			contentProtection: false,
			createdOn: new Date(),
			donation: 0,
			lastDonationDate: 'expired',
			allowedRoles: ['moderator', 'super', 'admin', 'owner', 'developer'],
			memberAllowedRoles: ['member', 'moderator', 'super', 'admin', 'owner', 'developer']
			
		};
		logActivity(ownerId, `Created room ${roomName}`, roomId);
		writeDatabase(database);
		return roomId;
	},

	/*
const createLobbyRoom = () => ({
	id: 'lobby',
	name: 'Lobby',
	owner: 'admin',
	topic: '',
	settings: {},
	suspendedUsers: [],
	mutedUsers: [],
	messages: [],
	admins: [],
	roles: [],
	users: [],
	vip: true,
	locked: false,
	slowMode: false,
	allowGuests: true,
	contentProtection: false,
	createdOn: new Date(),
	donation: 100,
	lastDonationDate: 'expired',
	allowedRoles: ['moderator', 'super', 'admin', 'owner', 'developer'],
	memberAllowedRoles: ['member', 'moderator', 'super', 'admin', 'owner', 'developer']
});
	*/

	/** Delete a room by ID.
	 * @param {string} roomId - ID of the room to delete.
	 * @param {string} userId - ID of the user attempting to delete the room.
	 * @returns {Promise<void>}
	 */
	deleteRoom: async (roomId, userId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || room.owner !== userId) throw new Error('Permission denied');
			logActivity(userId, `Deleted room ${room.name}`, roomId);
			delete database.rooms[roomId];
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Lock a room by ID.
	 * @param {string} roomId - ID of the room to lock.
	 * @param {string} userId - ID of the user attempting to lock the room.
	 * @returns {Promise<void>}
	 */
	lockRoom: async (roomId, userId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== userId && !room.admins.includes(userId))) throw new Error('Permission denied');
			room.locked = true;
			logActivity(userId, `Locked room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Unlock a room by ID.
	 * @param {string} roomId - ID of the room to unlock.
	 * @param {string} userId - ID of the user attempting to unlock the room.
	 * @returns {Promise<void>}
	 */
	unlockRoom: async (roomId, userId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== userId && !room.admins.includes(userId))) throw new Error('Permission denied');
			room.locked = false;
			logActivity(userId, `Unlocked room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Set the topic of a room by ID.
	 * @param {string} roomId - ID of the room.
	 * @param {string} topic - New topic for the room.
	 * @param {string} userId - ID of the user attempting to set the topic.
	 * @returns {Promise<void>}
	 */
	setRoomTopic: async (roomId, topic, userId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== userId && !room.admins.includes(userId))) throw new Error('Permission denied');
			room.topic = topic;
			logActivity(userId, `Set topic for room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Update the settings of a room by ID.
	 * @param {string} roomId - ID of the room.
	 * @param {Object} settings - New settings for the room.
	 * @param {string} userId - ID of the user attempting to update the settings.
	 * @returns {Promise<void>}
	 */
	updateRoomSettings: async (roomId, settings, userId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== userId && !room.admins.includes(userId))) throw new Error('Permission denied');
			Object.assign(room.settings, settings);
			logActivity(userId, `Updated settings for room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Enable slow mode in a room by ID.
	 * @param {string} roomId - ID of the room.
	 * @param {string} userId - ID of the user attempting to enable slow mode.
	 * @returns {Promise<void>}
	 */
	enableSlowMode: async (roomId, userId) => { //Need to finish client side delays on sendMsg
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== userId && !room.admins.includes(userId))) throw new Error('Permission denied');
			room.slowMode = true;
			logActivity(userId, `Enabled slow mode in room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Enable content protection in a room by ID.
	 * @param {string} roomId - ID of the room.
	 * @param {string} userId - ID of the user attempting to enable content protection.
	 * @returns {Promise<void>}
	 */
	enableContentProtection: async (roomId, userId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== userId && !room.admins.includes(userId))) throw new Error('Permission denied');
			room.contentProtection = true;
			logActivity(userId, `Enabled content protection in room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Suspend a user in a room for a temporary duration.
	 * @param {string} roomId - ID of the room.
	 * @param {string} userId - ID of the user to suspend.
	 * @param {string} adminId - ID of the admin suspending the user.
	 * @returns {Promise<void>}
	 */
	suspendUser: async (roomId, userId, adminId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== adminId && !room.admins.includes(adminId) && admin.role !== 'super')) throw new Error('Permission denied');
			const alreadySuspended = room.suspendedUsers.some(user => user.userId === userId && user.expiresAt > Date.now());
			if (alreadySuspended) return;
			room.suspendedUsers.push({ userId, expiresAt: Date.now() + 300000 });
			logActivity(adminId, `Suspended user ${userId} in room ${room.name} for 5 minutes`, roomId);
			writeDatabase(database);
			setTimeout(() => {
				room.suspendedUsers = room.suspendedUsers.filter(user => user.userId !== userId);
				writeDatabase(database);
			}, 300000);
		} catch (error) {
			handleError(error);
		}
	},

	/** Mute a user in a room by ID.
	 * @param {string} roomId - ID of the room.
	 * @param {string} userId - ID of the user to mute.
	 * @param {string} adminId - ID of the admin attempting to mute the user.
	 * @returns {Promise<void>}
	 */
	muteUserInRoom: async (roomId, userId, adminId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== adminId && !room.admins.includes(adminId) && admin.role !== 'super')) throw new Error('Permission denied');
			const alreadyMuted = room.mutedUsers.some(user => user.userId === userId);
			if (alreadyMuted) return;
			room.mutedUsers = room.mutedUsers || [];
			room.mutedUsers.push(userId);
			logActivity(adminId, `Muted user ${userId} in room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Unmute a user in a room by ID.
	 * @param {string} roomId - ID of the room.
	 * @param {string} userId - ID of the user to unmute.
	 * @param {string} adminId - ID of the admin attempting to unmute the user.
	 * @returns {Promise<void>}
	 */
	unmuteUserInRoom: async (roomId, userId, adminId) => {
		try {
			const room = database.rooms[roomId];
			if (!room || (room.owner !== adminId && !room.admins.includes(adminId) && admin.role !== 'super')) throw new Error('Permission denied');
			const checkMuted = room.mutedUsers.some(id => id === userId);
			if (!checkMuted) return;
			room.mutedUsers = room.mutedUsers.filter(id => id !== userId);
			logActivity(adminId, `Unmuted user ${userId} in room ${room.name}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},
	
	/** Follow a user by username.
	 * @param {string} userId - ID of the user who is following.
	 * @param {string} username - Username of the user to follow.
	 * @returns {Promise<void>}
	 */
	followUser: async (userId, username, skip = false) => {
		try {
			const userToFollow = database.users.find(u => u.username === username);
			if (!userToFollow && !skip) throw new Error('User to follow not found');
			const user = database.users.find(u => u.id === userId);
			const isBlocked = Array.from(user.blocked).some(blockedUser => blockedUser.uuid === userToFollow.id);
			if (isBlocked && !skip) throw new Error(`Cannot follow user.`);
			if (!user.following.includes(userToFollow.id)) {
				user.following.push(userToFollow.id);
				writeDatabase(database);
				logActivity(userId, `Followed user ${userToFollow.id}`, userId);
			}
		} catch (error) {
			handleError(error);
		}
	},

	/** Unfollow a user by username.
	 * @param {string} userId - ID of the user who is unfollowing.
	 * @param {string} username - Username of the user to unfollow.
	 * @returns {Promise<void>}
	 */
	unfollowUser: async (userId, username, skip = false) => {
		try {
			const userToUnfollow = database.users.find(u => u.username === username);
			if (!userToUnfollow && !skip) throw new Error('User to unfollow not found');
			const user = database.users.find(u => u.id === userId);
			user.following = user.following.filter(id => id !== userToUnfollow.id);
			writeDatabase(database);
			logActivity(userId, `Unfollowed user ${userToUnfollow.id}`, userId);
		} catch (error) {
			handleError(error);
		}
	},
	
	/** Block a user by username.
	 * @param {string} userId - ID of the user who is blocking.
	 * @param {string} username - Username of the user to block.
	 * @returns {Promise<void>}
	 */
	blockUser: async (userId, username, roomId) => {
		try {
			const userToBlock = database.users.find(u => u.username === username);
			if (!userToBlock) throw new Error('User to block not found');
			if (userToBlock.role === 'developer') throw new Error('Cannot block users with roles: developer');
			const user = database.users.find(u => u.id === userId);
			if (!user.blocked.includes(userToBlock.id)) {
				await roomManagement.unfollowUser(user.id, userToBlock.username, true);
				await streamManagement.unfollowStream(user.id, userToBlock.id, roomId, true);
				user.blocked.push(userToBlock.id);
				writeDatabase(database);
				logActivity(userId, `Blocked user ${userToBlock.id}`, userId);
			}
		} catch (error) {
			handleError(error);
		}
	},

	/** Unblock a user by username.
	 * @param {string} userId - ID of the user who is unblocking.
	 * @param {string} username - Username of the user to unblock.
	 * @returns {Promise<void>}
	 */
	unblockUser: async (userId, username) => {
		try {
			const userToUnblock = database.users.find(u => u.username === username);
			if (!userToUnblock) throw new Error('User to unblock not found');
			const user = database.users.find(u => u.id === userId);
			user.blocked = user.blocked.filter(id => id !== userToUnblock.id);
			writeDatabase(database);
			logActivity(userId, `Unblocked user ${userToUnblock.id}`, userId);
		} catch (error) {
			handleError(error);
		}
	}
};

/** Message Handling Functions
 * Grouping all functions related to message handling.
 */
const messageHandling = {
	/** Checks if the message contains spam based on recent messages.
	 * @param {string} message - The message to be checked for spam.
	 * @param {string[]} recentMessages - An array of recent messages from the user to compare against.
	 * @returns {boolean} - Returns true if the message is considered spam, false otherwise.
	 */
	detectSpam: (message, recentMessages) => {
		const contextBits = Array.from({ length: Math.ceil(message.length / 75) }, (_, i) => message.slice(i * 75, (i + 1) * 75).toLowerCase().trim());
		return recentMessages.some(recent => typeof recent === 'string' && contextBits.some(bit => recent.toLowerCase().includes(bit)));
	},

	/** Filters, sorts, and archives messages based on a timestamp threshold (default is 7 days).
	 * This function ensures only messages within the specified time range are kept in the database.
	 * @param {string} roomId - ID of the room.
	 * @param {Array} messages - An array of message objects, each containing a timestamp, user, and text.
	 * @param {number} [days=7] - The number of days used to determine the filtering threshold. Defaults to 7 days.
	 */
	processMessages: (roomId, days = 7) => {
		const now = Date.now(), threshold = days * 24 * 60 * 60 * 1000;
		const filteredMessages = (database.messages[roomId.toLowerCase()] ||= []).filter(({ timestamp }) => now - timestamp <= threshold);
		database.messages[roomId.toLowerCase()] = filteredMessages.sort((a, b) => a.timestamp - b.timestamp);
		writeDatabase(database);
	},

	/** Archive a message in the specified room.
	 * @param {string} roomId - ID of the room.
	 * @param {Object} message - Message object to archive.
	 */
	archiveMessage: (roomId, message) => {
		(database.messages[roomId.toLowerCase()] ||= []).push(message);
		writeDatabase(database);
	},

	/** Retrieve archived messages from the specified room.
	 * @param {string} roomId - ID of the room.
	 * @returns {Array} - Array of archived messages.
	 */
	getArchivedMessages: (roomId) => database.messages[roomId.toLowerCase()] ||= [],

	/** Add a reaction to a message by ID.
	 * @param {string} messageId - ID of the message.
	 * @param {string} emoji - Emoji reaction to add.
	 * @returns {Promise<void>}
	 */
	addReaction: async (messageId, emoji) => {
		try {
			Object.keys(database.messages).forEach(roomId => {
				const messageIndex = database.messages[roomId].findIndex(msg => msg.id === messageId);
				if (messageIndex !== -1) {
					database.messages[roomId][messageIndex].reactions = database.messages[roomId][messageIndex].reactions || [];
					database.messages[roomId][messageIndex].reactions.push(emoji);
					writeDatabase(database);
				}
			});
		} catch (error) {
			handleError(error);
		}
	}
};

/** Stream Management Functions
 * Grouping all functions related to stream management.
 */
const streamManagement = {
	/** Start a stream in a room by ID.
	 * @param {string} streamId - ID of the stream.
	 * @param {string} roomId - ID of the room.
	 * @param {string} username - Username of the stream owner.
	 * @returns {Promise<void>}
	 */
	startStream: async (streamId, roomId, username) => {
		try {
			database.streams.push({ id: streamId, roomId, username, active: true });
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** End a stream by ID.
	 * @param {string} streamId - ID of the stream to end.
	 * @returns {Promise<void>}
	 */
	endStream: async (streamId) => {
		try {
			database.streams = database.streams.filter(stream => stream.id !== streamId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Check if a stream is active in a room by stream ID and room ID.
	 * @param {string} streamId - ID of the stream to check.
	 * @param {string} roomId - ID of the room to check.
	 * @returns {Promise<boolean>} - True if the stream is active, otherwise false.
	 */
	isStreaming: async (streamId, roomId) => {
		try {
			const stream = database.streams.find(stream => stream.id === streamId && stream.roomId === roomId && stream.active);
			return !!stream;
		} catch (error) {
			handleError(error);
			return false;
		}
	},

	/** Follow a stream by ID.
	 * @param {string} userId - ID of the user.
	 * @param {string} streamId - ID of the stream to follow.
	 * @returns {Promise<void>}
	 */
	followStream: async (userId, streamId, roomId) => {
		//on blocked remove if following stream & add option user allowUserFollows & allowStreamFollows
		try {
			const room = database.rooms[roomId];
			if (!room) throw new Error('Room not found');
			const user = userManagement.findUserById(userId);
			if (!user) throw new Error('User not found');
			const streamer = userManagement.findUserById(streamId);
			if (!streamer) throw new Error('Streamer not found');
			const isBlocked = Array.from(user.blocked).some(blockedUser => blockedUser.uuid === streamer.id);
			if (isBlocked) throw new Error(`Cannot follow stream.`);
			if (!room.follows[user.id]) room.follows[user.id] = [];
			room.follows[user.id].push(streamer.id);
			writeDatabase(room);
		} catch (error) {
			handleError(error);
		}
	},

	/** Unfollow a stream by ID.
	 * @param {string} userId - ID of the user.
	 * @param {string} streamId - ID of the stream to unfollow.
	 * @returns {Promise<void>}
	 */
	unfollowStream: async (userId, streamId, roomId, skip = false) => {
		try {
			const room = database.rooms[roomId];
			if (!room && !skip) throw new Error('Room not found');
			const user = userManagement.findUserById(userId);
			if (!user && !skip) throw new Error('User not found');
			const streamer = userManagement.findUserById(streamId);
			if (!streamer && !skip) throw new Error('Streamer not found');
			if (room.follows[userId]) {
				room.follows[userId] = room.follows[userId].filter(id => id !== streamer.id);
				writeDatabase(room);
			} else if (!skip) throw new Error('User not following stream');
		} catch (error) {
			handleError(error);
		}
	},

	/** Start recording a stream.
	 * @param {string} streamId - ID of the stream to record.
	 */
	startRecording: async (streamId) => {
		try {
			database.recordings.push({ streamId, active: true });
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Stop recording a stream.
	 * @param {string} streamId - ID of the stream to stop recording.
	 */
	stopRecording: async (streamId) => {
		try {
			const recordingIndex = database.recordings.findIndex(recording => recording.streamId === streamId);
			if (recordingIndex !== -1) {
				database.recordings[recordingIndex].active = false;
				writeDatabase(database);
			}
		} catch (error) {
			handleError(error);
		}
	}
};

/** Utility Functions
 * Grouping miscellaneous utility functions.
 */
const utilities = {
	/** Log user activity.
	 * @param {string} userId - ID of the user.
	 * @param {string} activity - Activity description.
	 * @param {string} [roomId] - ID of the room where the activity occurred (optional).
	 */
	logActivity,

	/** Share a file in a specific room.
	 * @param {string} roomId - ID of the room.
	 * @param {Object} file - File object to share.
	 * @returns {Promise<void>}
	 */
	shareFile: async (roomId, file) => {
		try {
			if (!database.files[roomId]) database.files[roomId] = [];
			database.files[roomId].push(file);
			logActivity(file.uploader, `Shared a file in room ${roomId}`, roomId);
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Check if the user has exceeded the rate limit.
	 * @param {string} userId - ID of the user.
	 * @returns {Promise<boolean>} - True if the user is within the limit, false otherwise.
	 */
	checkRateLimit: async (userId) => {
		try {
			if (!database.rateLimits[userId]) database.rateLimits[userId] = { count: 0, timestamp: Date.now() };
			const currentTime = Date.now();
			const timeDifference = currentTime - database.rateLimits[userId].timestamp;
			if (timeDifference > 60000) {
				database.rateLimits[userId].count = 1;
				database.rateLimits[userId].timestamp = currentTime;
			} else database.rateLimits[userId].count += 1;
			writeDatabase(database);
			return database.rateLimits[userId].count <= 10;
		} catch (error) {
			handleError(error);
		}
	},

	/** Track user activity. - All data gets cleaned up after 2 days
	 * @param {string} userId - ID of the user.
	 * @param {string} activity - Activity description.
	 * @returns {Promise<void>}
	 */
	trackUserActivity: async (userId, activity) => {
		try {
			const twoDaysAgo = new Date();
			twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
			database.activities = database.activities.filter(activity => new Date(activity.timestamp) >= twoDaysAgo);
			database.activities.push({ userId, activity, timestamp: new Date() });
			writeDatabase(database);
		} catch (error) {
			handleError(error);
		}
	},

	/** Reward a random active user.
	 * @returns {Promise<Object>} - Rewarded user object.
	 */
	rewardRandomActiveUser: async () => {
		try {
			const activeUsers = database.users.filter(user => user.status === 'online');
			if (activeUsers.length === 0) throw new Error('No active users to reward');
			const rewardedUser = QPRx2025.theRewarded(activeUsers);
			return rewardedUser;
		} catch (error) {
			handleError(error);
		}
	}
};

/** Poll Management Functions
 * Grouping all functions related to poll management.
 */
const pollManagement = {
	/** Create a new poll.
	 * @param {string} question - The poll question.
	 * @param {Array} options - Array of poll options.
	 * @param {string} createdBy - ID of the user creating the poll.
	 * @returns {Object} - The created poll object.
	 */
	createPoll: (question, options, createdBy) => {
		const user = userManagement.findUserByUsername(createdBy);
		if (user) {
			const poll = {
				id: QPRx2025.generateUUID(),
				question,
				options: options.map(option => ({ text: option, votes: 0 })),
				createdBy,
				createdAt: new Date()
			};
			database.polls.push(poll);
			writeDatabase(database);
			logActivity(user.uuid, `${user.username} created a new poll: ${poll.question}`, poll.id);
			return poll;
		}
	},

	/** Vote in a poll.
	 * @param {string} pollId - ID of the poll.
	 * @param {number} optionIndex - Index of the option to vote for.
	 * @param {string} userId - ID of the user voting.
	 * @returns {Promise<void>}
	 */
	votePoll: async (pollId, optionIndex, userId) => {
		try {
			const user = userManagement.findUserById(userId);
			if (user) {
				const poll = database.polls.find(p => p.id === pollId);
				if (!poll) throw new Error('Poll not found');
				poll.options[optionIndex].votes += 1;
				logActivity(userId, `${user.username} voted in poll ${poll.question}`, pollId);
				writeDatabase(database);
			}
		} catch (error) {
			handleError(error);
		}
	},

	/** Load existing polls for voting.
	 * @param {string} userId - ID of the user loading polls.
	 * @returns {Array} - An array of active polls with voting options.
	 */
	loadPolls: (userId) => {
		try {
			const user = userManagement.findUserById(userId);
			if (!user) throw new Error('User not found');
			const activePolls = database.polls.filter(poll => poll.createdAt >= new Date(Date.now() - 7 * 24 * 60 * 60 * 1000));
			return activePolls.map(poll => ({
				id: poll.id,
				question: poll.question,
				options: poll.options.map((option, index) => ({
					index,
					text: option.text,
					votes: option.votes
				}))
			}));
		} catch (error) {
			handleError(error);
			return [];
		}
	}
};

/** Clip Management Functions
 * Grouping all functions related to clip management.
 */
const clipManagement = {
	/** Create a new clip.
	 * @param {string} streamId - ID of the stream.
	 * @param {string} createdBy - ID of the user creating the clip.
	 * @param {Object} clipData - Data related to the clip.
	 * @returns {Object} - The created clip object.
	 */
	createClip: (streamId, createdBy, clipData) => {
		const clip = {
			id: QPRx2025.generateUUID(),
			streamId,
			createdBy,
			clipData,
			createdAt: new Date()
		};
		database.clips.push(clip);
		writeDatabase(database);
		return clip;
	},

	/** Delete a clip.
	 * @param {string} clipId - ID of the clip to delete.
	 * @returns {Promise<void>}
	 */
	deleteClip: async (clipId) => {
		database.clips = database.clips.filter(clip => clip.id !== clipId);
		writeDatabase(database);
	}
};

/** Recommendation Management Functions
 * Grouping all functions related to recommendation management.
 */
const recommendationManagement = {
	/** Create a new recommendation.
	 * @param {string} type - Type of the recommendation.
	 * @param {Object} data - Data related to the recommendation.
	 * @returns {Object} - The created recommendation object.
	 */
	createRecommendation: (type, data) => {
		const recommendation = {
			id: QPRx2025.generateUUID(),
			type,
			data,
			createdAt: new Date()
		};
		database.recommendations.push(recommendation);
		writeDatabase(database);
		return recommendation;
	},

	/** Delete a recommendation.
	 * @param {string} recommendationId - ID of the recommendation to delete.
	 * @returns {Promise<void>}
	 */
	deleteRecommendation: async (recommendationId) => {
		database.recommendations = database.recommendations.filter(rec => rec.id !== recommendationId);
		writeDatabase(database);
	}
};

/** Loyalty Points Management Functions
 * Grouping all functions related to loyalty points management.
 */
const loyaltyPointsManagement = {
	/** Add loyalty points to a user.
	 * @param {string} userId - ID of the user.
	 * @param {number} points - Number of points to add.
	 * @returns {Promise<void>}
	 */
	addPoints: async (userId, points) => {
		const user = database.users.find(user => user.id === userId);
		if (!user) throw new Error('User not found');
		user.loyaltyPoints = (user.loyaltyPoints || 0) + points;
		writeDatabase(database);
	},

	/** Redeem loyalty points for a user.
	 * @param {string} userId - ID of the user.
	 * @param {number} points - Number of points to redeem.
	 * @returns {Promise<void>}
	 */
	redeemPoints: async (userId, points) => {
		const user = database.users.find(user => user.id === userId);
		if (!user) throw new Error('User not found');
		if (user.loyaltyPoints < points) throw new Error('Insufficient points');
		user.loyaltyPoints -= points;
		writeDatabase(database);
	}
};

/** Badge Management Functions
 * Grouping all functions related to badge management.
 */
const badgeManagement = {
	/** Award a badge to a user.
	 * @param {string} userId - ID of the user.
	 * @param {string} badge - Badge to award.
	 * @returns {Promise<void>}
	 */
	awardBadge: async (userId, badge) => {
		const user = database.users.find(user => user.id === userId);
		if (!user) throw new Error('User not found');
		user.badges = user.badges || [];
		user.badges.push(badge);
		writeDatabase(database);
	},

	/** Remove a badge from a user.
	 * @param {string} userId - ID of the user.
	 * @param {string} badge - Badge to remove.
	 * @returns {Promise<void>}
	 */
	removeBadge: async (userId, badge) => {
		const user = database.users.find(user => user.id === userId);
		if (!user) throw new Error('User not found');
		user.badges = user.badges.filter(b => b !== badge);
		writeDatabase(database);
	}
};

/** Social Sharing Functions
 * Grouping all functions related to social sharing.
 */
const socialSharing = {
	/** Share content on social media.
	 * @param {string} userId - ID of the user sharing the content.
	 * @param {Object} content - Content to share.
	 * @param {string} platform - Social media platform.
	 * @returns {Promise<void>}
	 */
	shareContent: async (userId, content, platform) => {
		const share = {
			id: QPRx2025.generateUUID(),
			userId,
			content,
			platform,
			timestamp: new Date()
		};
		database.socialShares.push(share);
		logActivity(userId, `Shared content on ${platform}`, null);
		writeDatabase(database);
	}
};

module.exports = {
	badWords,
	database,
	restrictedNames,
	...userManagement,
	...roomManagement,
	...messageHandling,
	...streamManagement,
	...utilities,
	...pollManagement,
	...clipManagement,
	...recommendationManagement,
	...loyaltyPointsManagement,
	...badgeManagement,
	...socialSharing
};